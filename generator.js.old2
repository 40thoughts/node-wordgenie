'use strict';
var sizeof = require('object-sizeof');

class Generator {
  constructor(markovLen) {
    this.markovLen = markovLen;
    this.stats = new Map();
  }
  
  analyse(words) {
    //console.log(words);
    let _letters = new Set();
    let _syllables = new Set();
    let _words = new Set();
    
    words.forEach((word) => {
      _words.add('!' + word + '?');
    });
    
    _words.forEach((word) => {
      let _word = word;
      //console.log('Word : ' + _word);
      for (let c = 0; c < _word.length; c++) {
        _letters.add(_word[c]);
        //console.log('Letter : ' + _word[c]);
        if (c >= this.markovLen) {
          let _syllable = '';
          for (let x = this.markovLen-1; x >= 0; x--) {
            _syllable += _word[c-x];
            //console.log('Syll : ' + _syllable);
          }
          _syllables.add(_syllable);
        } else {
          let _syllable = '';
          for (let x = c; x >= 0; x--) {
            _syllable += _word[c-x];
            //console.log('Syll : ' + _syllable);
          }
          _syllables.add(_syllable);
        }
      }
    });
    
    console.log(_letters);
    console.log(_syllables);
    
    _syllables.forEach((syllable) => {
      let _syllable = [...syllable];
      parseString(_syllable, this.stats, _letters);
    });
    
    _words.forEach((word) => {
      //let _word = word;
      let _word = [...word];
      for (let c = 1; c < word.length; c++) {
        //let _word = [...word];
        let _substring = _word.slice(Math.max(c - this.markovLen, 0), c + 1);
        let _letter = _substring.splice(_substring.length - 1);
        //console.log('Word : ' + _substring);
        //console.log('Word : ' + _word);
        //console.log('Letter : ' + _letter);
        incStat(_substring, this.stats, _letter);
      }
    });
    
    console.log('MAP : ' + JSON.stringify(this.stats, 0, 2));
    //console.log('Return : ' + JSON.stringify(this.stats['\r'], 0, 2));
    //console.log('NewLine : ' + JSON.stringify(this.stats['\n']));
    ////console.log('Map : ' + JSON.stringify(this.stats['!'], 0, 2));
    //var ratio = Math.max(...this.stats['!']) / 100;
    //this.stats['!'] = Array.from(this.stats['!']).map(v => Math.round(v / ratio));
    //[...this.stats['!']].map((val) => {console.log('Val : ' + val)});
    //console.log('MapReduced : ' + JSON.stringify(this.stats['!'], 0, 2));
    for (var key of this.stats.keys()) {
      console.log(key);
    }
    normalize(this.stats);
    
    console.log('Size : ' + sizeof(this.stats));
  }
}


function normalize(myMap) {
  console.log(myMap.values());
  for (var key of myMap.keys()) {
    console.log(key);
  }
}


function incStat(arr, map, letter) {
  //console.log('Arr : ' + arr);
  //console.log('Letter : ' + letter);
  let _lastLetter = arr.splice(arr.length-1,1);
  //console.log('Arr2 : ' + arr);
  //console.log('LastLetter : ' + _lastLetter);
  
  let _map = map[_lastLetter];
  //console.log('Passing letter ' + letter + ' to map ' + _lastLetter);
  if (arr.length > 0) {
    incStat(arr, _map, letter);
  } else {
    _map[letter] += 1;
  }
}


function parseString(arr, map, letters) {
  if (arr.length != 0) {
    let _letter = arr.splice(arr.length-1,1);
    if (map.has(_letter)) {
      map = map.get(_letter);
    } else {
      map = map.set(_letter, new Map());
    }
    //map[_letter] = map[_letter] || new Map();
    parseString(arr, map[_letter], letters);
  } else {
    letters.forEach((letter) => {
      map.set(letter, 0);
      //map[letter] = 0;
    });
  }
}


module.exports = exports = Generator;
